#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <curl/curl.h>
#include <cJSON.h>

#include "vulners_wazuh.h"

#define CURL_VULNERS_AGENT "User-Agent: vulners-wazuh/0.1"
#define CURL_VULNERS_CONTENT_TYPE "Content-type: application/json"
#define CURL_VULNERS_CONTENT_LENGTH "Content-length: %d"
#define VULNERS_URL "https://vulners.com/api/v3/audit/audit/"
#define TEST_PROXY_URL "http://172.16.47.1:8089"
#define VULNERS_PAYLOAD "{\"os\": \"%s\", \"version\": %s, \"package\": [%s], \"apiKey\": \"%s\"}"
#define PACKAGES_FILE "/home/gmedian/Documents/projects/vulners/integrations/wazuh/test_url/packs.txt"
#define VULNERS_PAYLOAD_FILE "/home/gmedian/Documents/projects/vulners/integrations/wazuh/test_url/payload.txt"
#define VULNERS_RESULT_FILE "/home/gmedian/Documents/projects/vulners/integrations/wazuh/test_url/result.txt"
#define VULNERS_VULN_PACKAGES_FILE "/home/gmedian/Documents/projects/vulners/integrations/wazuh/test_url/vulnerable.txt"
#define VULNERS_KEY_FILE "/home/gmedian/Documents/projects/vulners/integrations/wazuh/test_url/vulners_key.txt"
#define ALLOC_STEP 128
#define STR_MAX_LEN 255 // + \0

#define check_null(ptr, msg) \
                            if(ptr == NULL) \
                            {\
                                perror(msg); \
                                goto end; \
                            }

// -D LOCAL_BUILD
#ifdef LOCAL_BUILD
int main(int argc, char **argv, char **env)
#else
int vulners_main()
#endif
{
    char *vulners_key=(char*)malloc(65*sizeof(char)); //API key len + \0
    FILE *v_key_fPtr=NULL;

    if(v_key_fPtr=fopen(VULNERS_KEY_FILE, "r"), !v_key_fPtr)
    {
        perror("No vulners api key file found.");
        return -1;
    }
    fgets(vulners_key, 65, v_key_fPtr);

    fclose(v_key_fPtr);

    char **packages_list=NULL;
    get_packages(PACKAGES_FILE, &packages_list);
    
    if(!packages_list)
    {
        return -1;
    }

    cJSON *payload=cJSON_CreateObject(); 

    // FIXME add real os name here
    if (cJSON_AddStringToObject(payload, "os", "centos") == NULL)
    {
        perror("Can't add os field to JSON payload");
        goto end;
    }
    if (cJSON_AddStringToObject(payload, "version", "7.10") == NULL)
    {
        perror("Can't add version field to JSON payload");
        goto end;
    }
    if (cJSON_AddStringToObject(payload, "apiKey", vulners_key) == NULL)
    {
        perror("Can't add version field to JSON payload");
        goto end;
    }

    cJSON *packages_array=cJSON_AddArrayToObject(payload, "package");


    for(char **it=packages_list; *it != NULL; it++)
    {
        cJSON *package_name=cJSON_CreateString(*it);
        if(package_name == NULL)
        {
            perror("Cant create JSON string field.");
            goto end;
        }
        cJSON_AddItemToArray(packages_array, package_name);
    }

    char *payload_str=cJSON_Print(payload);

    FILE *ofPtr=fopen(VULNERS_PAYLOAD_FILE, "w");

    if(!ofPtr)
    {
        fputs("Error in opening file for writing payload", stderr);
        ofPtr = stdout;
    }
    fputs(payload_str, ofPtr);
    fclose(ofPtr);

    CURL *curl=curl_easy_init();
    CURLcode res;
    char errbuf[CURL_ERROR_SIZE];
    struct curl_slist *c_header=NULL; 

    // char *buffer=(char*)calloc(1000, sizeof(char));

    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, NULL);
    curl_easy_setopt(curl, CURLOPT_URL, VULNERS_URL);
    curl_easy_setopt(curl, CURLOPT_PROXY, TEST_PROXY_URL);
    
    c_header = curl_slist_append(c_header, CURL_VULNERS_AGENT);
    c_header = curl_slist_append(c_header, CURL_VULNERS_CONTENT_TYPE);
    
    // printf("Getting content-length: actual length is %d\n", strlen(VULNERS_PAYLOAD));

    // snprintf(buffer, 900, CURL_VULNERS_CONTENT_LENGTH, strlen(VULNERS_PAYLOAD));
    // c_header = curl_slist_append(c_header, buffer);

    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, c_header);

    FILE *ifPtr = fopen(VULNERS_PAYLOAD_FILE, "r");

    if(!ifPtr)
    {
        perror("Cant reopen file with payload for reading.\n");
        return -1;
    }

    // curl_easy_setopt(curl, CURLOPT_READFUNCTION, NULL);
    curl_easy_setopt(curl, CURLOPT_POST, 1L);
    curl_easy_setopt(curl, CURLOPT_READDATA, ifPtr);

    ofPtr = fopen(VULNERS_RESULT_FILE, "w");

    if(!ofPtr)
    {
        perror("Cant open file for vulners result.\n");
        ofPtr = NULL;
    }

    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, NULL);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, ofPtr);

    // curl_easy_setopt(curl, CURLOPT_POSTFIELDS, VULNERS_PAYLOAD);

    if(!strncmp(VULNERS_URL, "https", 5)){
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
    }

    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf);
    curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);

    res = curl_easy_perform(curl);

    // in order to work on we need all the data present in the files
    // so flush the OS buffers now
    fclose(ifPtr);
    fclose(ofPtr);

    switch (res)
    {
    case CURLE_OK:
        printf("Got OK\n");
        write_vulns();
        break;
    
    default:
        printf("Some problem arose. \n%s\n", errbuf);
        break;
    }

    curl_slist_free_all(c_header);
    curl_easy_cleanup(curl);

end:
    cJSON_Delete(payload);

#ifndef LOCAL_BUILD
    free(vulners_key);
#endif

    // write_vulns();

    // call wm_vuldet_send_cve_report here with report on vulnerabilities

    return 0;
}

void get_packages(const char *filename, char ***packages_array)
{
    char **reallocPtr=NULL;
    FILE *fPtr=fopen(filename, "r");

    if(fPtr == NULL)
    {
        fputs("Error in opening file for reading package list", stderr);
        return;
    }

    *packages_array=(char**)calloc(ALLOC_STEP, sizeof(char*));
    if(*packages_array == NULL)
    {
        perror("Can't calloc memory for packages array in get_packages.");
        fclose(fPtr);
        return;
    }

    char *buf=NULL;
    u_int count=0, max_count=ALLOC_STEP;

    while(!feof(fPtr))
    {
        if(count >= max_count)
        {
            max_count += ALLOC_STEP;
            reallocPtr = (char**)realloc(*packages_array, max_count * sizeof(char*));
            if(reallocPtr == NULL)
            {
                // here packages_array still exists and holds data
                perror("Can't realloc for packages reading in get_packages. Continue with the existing ones.");
                break;
            }
            // otherwise - old packages_array is already freed
            *packages_array = reallocPtr;
        }
        (*packages_array)[count] = (char*)malloc(STR_MAX_LEN * sizeof(char));
        if((*packages_array)[count] == NULL)
        {
            perror("Can't malloc memory for another package name. Continue with the existing ones.");
            break;
        }
        buf = fgets((*packages_array)[count], STR_MAX_LEN, fPtr);
        if(!buf)
        {
            if(ferror(fPtr))
            {
                // debug
                perror("Some error at reading the file. But something might have been read, so continue.");
                break;
            }
            else
            {
                // otherwise it is just an EOF right at the start, so just break out
                break;
            }
            
        }
        buf[strlen(buf)-1] = buf[strlen(buf)-1] == '\n'?'\0':buf[strlen(buf)-1]; //overwrite the present newline character
        count++;
    }

    fclose(fPtr); // success or not, it does not matter - we did our best here
    if(!count)
    {
        // nothing read, return NULL
        free(*packages_array);
        return;
    }
    else
    {
        reallocPtr = (char**)realloc(*packages_array, (count+1) * sizeof(char*));
        if(reallocPtr == NULL)
        {
            perror("Can't shrink memory with realloc after reading packages. Continue with the old size.");
        }
        else
        {
            *packages_array = reallocPtr;
        }
        
        (*packages_array)[count] = NULL;
        return;
    }
}

void write_vulns()
{
    FILE *ifPtr=fopen(VULNERS_RESULT_FILE, "r");

    if(ifPtr == NULL)
    {
        perror("Can't reopen VULNERS_RESULT file for reading");
        return;
    }

    FILE *ofPtr=fopen(VULNERS_VULN_PACKAGES_FILE, "w");
    if(ofPtr == NULL)
    {
        perror("Can't open VULNERS_VULN file for writing");
        fclose(ifPtr);
        return; 
    }

    fseek (ifPtr, 0 , SEEK_END);
    long lSize = ftell (ifPtr);
    rewind (ifPtr);

    char *j_str=(char*)malloc(lSize * sizeof(char) + 1);
    check_null(j_str, "Can't malloc memory for json response.\n");
    if(fread(j_str, sizeof(char), lSize, ifPtr) < lSize)
    {
        // Since we tried for exactly the file size, no EOF could have been met
        // so an error must have occured
        perror("Some error at reading file with the json result.\n");
        free(j_str);
        goto end;
    }
    j_str[lSize] = '\0';

    cJSON *in_json=cJSON_Parse(j_str);
    cJSON *new_res=cJSON_CreateObject();

    if(in_json == NULL)
    {
        const char *error_ptr = cJSON_GetErrorPtr();
        if (error_ptr != NULL)
        {
            fprintf(stderr, "Error at json parsing before: %s\n", error_ptr);
        }
        free(j_str);
        goto end;
    }


    // if res.status_code == 200 and res.json().get('result') == "OK":
    // result = dict()
    // all_cve = list()
    // for pkg, info in res.json()['data'].get('packages', {}).items():
    //     cvelist = []
    //     for vuln_name, desc in info.items():
    //         cvelist.append(sum(map(lambda x: x.get("cvelist", []), desc), []))
    //     cvelist = list(set(sum(cvelist, [])))
    //     if len(cvelist):
    //         result[pkg] = {"cve": cvelist}
    //         all_cve += cvelist
    // result['all_cve'] = all_cve
    // return result

    cJSON *item=NULL, *new_pkg=NULL, *pkg_obj=NULL, *pkg=NULL, *vuln=NULL, *vuln_reason=NULL,
        *cvelist=NULL, *cve=NULL;
    item = cJSON_GetObjectItemCaseSensitive(in_json, "result");
    if(cJSON_IsString(item) && !strcmp(item->valuestring, "OK"))
    {
        printf("Everything worked fine. We have OK in result!\n");
    }
    else
    {
        printf("Not OK in result or no result. We are totally doomed!\n");
        goto j_end;
    }

    item = cJSON_GetObjectItemCaseSensitive(in_json, "data");
    if(!cJSON_IsObject(item))
    {
        perror("\"data\" field not present or is not an object\n");
        goto j_end;
    }

    pkg_obj = cJSON_GetObjectItemCaseSensitive(item, "packages");
    if(!cJSON_IsObject(pkg_obj))
    {
        perror("\"packages\" field not present or is not an object\n");
        goto j_end;
    }

    cJSON_ArrayForEach(pkg, pkg_obj)
    {
        // pkg is an object
        if(!cJSON_IsObject(pkg))
        {
            perror("Single package is not an object\n");
            // assume some other packages might be found
            continue;
        }
        printf("Scanning for %s\n", pkg->string);
        new_pkg = cJSON_AddObjectToObject(new_res, pkg->string);
        cJSON *new_cvelist=cJSON_AddArrayToObject(new_pkg, "cvelist");
        cJSON_ArrayForEach(vuln, pkg)
        {
            // vuln is an array with reasons
            if(!cJSON_IsArray(vuln))
            {
                fprintf(stderr, "Single vuln in package %s is not an array\n", pkg->string);
                continue;
            }

            cJSON_ArrayForEach(vuln_reason, vuln)
            {
                // vuln_reason is an object
                if(!cJSON_IsObject(pkg))
                {
                    fprintf(stderr, "Single vuln_reason in %s and vuln %s is not an object\n", 
                            pkg->string, vuln->string);
                    continue;
                }
                cvelist = cJSON_GetObjectItemCaseSensitive(vuln_reason, "cvelist");
                if(!cJSON_IsArray(cvelist))
                {
                    // cvelist may be absent, so no big deal here
                    continue;
                }
                cJSON_ArrayForEach(cve, cvelist)
                {
                    if(!cJSON_IsString(cve))
                    {
                        fprintf(stderr, "Single cve in cvelist of pkg %s and vuln %s is not a string\n", 
                            pkg->string, vuln->string);
                    continue;
                    }
                    // FIXME remove duplicates
                    cJSON_AddItemReferenceToArray(new_cvelist, cve);
                }
            }
        }
    }

    free(j_str);
    j_str = cJSON_Print(new_res);
    if(j_str == NULL)
    {
        perror("Somethig horrible has happened - can't print the new result\n");
        goto j_end;
    }
    fputs(j_str, ofPtr);

j_end:    
    cJSON_Delete(in_json);
    cJSON_Delete(new_res);
    free(j_str);
end:
    fclose(ifPtr);
    fclose(ofPtr);
    return;
}
