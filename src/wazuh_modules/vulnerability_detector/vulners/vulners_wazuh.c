#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <curl/curl.h>
#include <cJSON.h>

#include "vulners_wazuh.h"
#ifndef LOCAL_BUILD
    #include "../../wmodules.h"
    #include "../wm_vuln_detector.h"
#endif
#define VULNERS_API_KEY_LEN 65
#define CURL_VULNERS_AGENT "User-Agent: vulners-wazuh/0.1"
#define CURL_VULNERS_CONTENT_TYPE "Content-type: application/json"
#define CURL_VULNERS_CONTENT_LENGTH "Content-length: %d"
#define VULNERS_URL "https://vulners.com/api/v3/audit/audit/"
#define TEST_PROXY_URL "http://172.16.47.1:8089"
#define VULNERS_PAYLOAD "{\"os\": \"%s\", \"version\": %s, \"package\": [%s], \"apiKey\": \"%s\"}"
#define PACKAGES_FILE "/home/gmedian/Documents/projects/vulners/integrations/wazuh/test_url/packs.txt"
#define VULNERS_PAYLOAD_FILE "/home/gmedian/Documents/projects/vulners/integrations/wazuh/test_url/payload.txt"
#define VULNERS_RESULT_FILE "/home/gmedian/Documents/projects/vulners/integrations/wazuh/test_url/result.txt"
#define VULNERS_VULN_PACKAGES_FILE "/home/gmedian/Documents/projects/vulners/integrations/wazuh/test_url/vulnerable.txt"
#define VULNERS_KEY_FILE "/home/gmedian/Documents/projects/vulners/integrations/wazuh/test_url/vulners_key.txt"
#define ALLOC_STEP 128
#define STR_MAX_LEN 255 // + \0

/**
 * TODO[gmedian]
 * - load packages from wdb rather than file
 * - remove duplicates from vulners results
 * - send 'report' to wdb
 * - refactoring
 * - merge into latest release (we are ***ed here)
*/

// -D LOCAL_BUILD
#ifdef LOCAL_BUILD
int main(int argc, char **argv, char **env)
#else
int vulners_main(char *agent_id)
#endif
{
    int result=0;

    char *vulners_key=(char*)malloc(VULNERS_API_KEY_LEN*sizeof(char)); //API key len + \0

    result = get_vulners_api_key(&vulners_key);
    if(result)
    {
        perror("Failed to get vulners_api_key.");
        free(vulners_key);
        return -1;
    }

    char **packages_list=NULL;
    get_packages(PACKAGES_FILE, &packages_list);
    
    if(!packages_list)
    {
        return -1;
    }

#ifdef LOCAL_BUILD
    char *agent_id="000";
#endif

    struct v_os_info os_info;
    result = get_os_info(&os_info, agent_id);

    if(result)
    {
        fprintf(stderr, "Could not receive os_info for agent_id %s\n", agent_id);
        goto end;
    }

    cJSON *payload=get_cJSON_payload(packages_list, &os_info, vulners_key);
    free(os_info.os_version);
    free(os_info.os_platform);

    if(!payload)
    {
        fprintf(stderr, "Could not build cJSON payload for agent_id %s\n", agent_id);
        goto end;
    }
    char *payload_str=cJSON_Print(payload);
    cJSON_Delete(payload);

    struct Memory res_memory;
    res_memory.memory = malloc(1);
    res_memory.size = 0;

    struct Memory payload_memory;
    payload_memory.memory = payload_str;
    payload_memory.size = strlen(payload_str);

    int res=perform_vulners_request(&payload_memory, &res_memory);

    // due to the way read_callback reads memory we can only free memory of payload_str
    free(payload_str);

    if(res)
    {
        // some error occured, the detailed message has already been delievered
        perror("Error with curl occured, can not continue.");
        free(res_memory.memory);
        goto end;
    }

    write_vulns(&res_memory);

    free(res_memory.memory);

end:
    free(vulners_key);

    // call wm_vuldet_send_cve_report here with report on vulnerabilities

    return 0;
}

int perform_vulners_request(struct Memory *dataPtr, struct Memory *resPtr)
{
    CURL *curl=curl_easy_init();
    int res=-1;
    char errbuf[CURL_ERROR_SIZE];
    struct curl_slist *c_header=NULL; 


    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, NULL);
    curl_easy_setopt(curl, CURLOPT_URL, VULNERS_URL);
    curl_easy_setopt(curl, CURLOPT_PROXY, TEST_PROXY_URL);
    
    c_header = curl_slist_append(c_header, CURL_VULNERS_AGENT);
    c_header = curl_slist_append(c_header, CURL_VULNERS_CONTENT_TYPE);
    c_header = curl_slist_append(c_header, "Transfer-Encoding: chunked");
    
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, c_header);


    curl_easy_setopt(curl, CURLOPT_READFUNCTION, read_callback);
    curl_easy_setopt(curl, CURLOPT_POST, 1L);
    curl_easy_setopt(curl, CURLOPT_READDATA, dataPtr);
    

    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, resPtr);

    // TODO[gmedian]: fix SSL here
    if(!strncmp(VULNERS_URL, "https", 5)){
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
    }

    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf);
    curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);

    CURLcode curl_res = curl_easy_perform(curl);

    switch (curl_res)
    {
    case CURLE_OK:
        fprintf(stderr,"curl to vulners is successfull\n");
        res = 0;
        break;
    
    default:
        fprintf(stderr, "Some curl problem arose. \n%s\n", errbuf);
        break;
    }

    curl_slist_free_all(c_header);
    curl_easy_cleanup(curl);

    return res;
}

cJSON* get_cJSON_payload(char **packages_list, struct v_os_info *os_info_Ptr, char *vulners_key)
{
    int result=0;

    cJSON *payload=cJSON_CreateObject(); 


    // FIXME add real os name here
    if (cJSON_AddStringToObject(payload, "os", os_info_Ptr->os_platform) == NULL)
    {
        perror("Can't add os field to JSON payload");
        goto error;
    }
    if (cJSON_AddStringToObject(payload, "version", os_info_Ptr->os_version) == NULL)
    {
        perror("Can't add version field to JSON payload");
        goto error;
    }
    if (cJSON_AddStringToObject(payload, "apiKey", vulners_key) == NULL)
    {
        perror("Can't add version field to JSON payload");
        goto error;
    }


    cJSON *packages_array=cJSON_AddArrayToObject(payload, "package");


    for(char **it=packages_list; *it != NULL; it++)
    {
        cJSON *package_name=cJSON_CreateString(*it);
        if(package_name == NULL)
        {
            perror("Can't create JSON string field.");
            goto error;
        }
        cJSON_AddItemToArray(packages_array, package_name);
    }

    return payload;
error:
    cJSON_Delete(payload);
    return NULL;
}

int get_os_info(struct v_os_info *os_info_Ptr, char *agent_id)
{
    int retval=-1;
#ifndef LOCAL_BUILD
    char request[OS_SIZE_128];


    snprintf(request, OS_SIZE_128, "agent %s sql SELECT os_version, os_platform FROM SYS_OSINFO;", agent_id);

    mtdebug1(WM_VULNDETECTOR_LOGTAG, "gmedian trying to send request \"%s\" to wdb", request);

    if (wm_vuldet_wdb_request(request, OS_MAXSTR)) {
        goto end;
    }

    mtdebug1(WM_VULNDETECTOR_LOGTAG, "gmedian got response \"%s\" fom wdb", request);

    if (!wm_vuldet_wdb_valid_answ(request)) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_INV_WAZUHDB_RES, request);
        goto end;
    }

    // Check empty answers
    if (wm_vuldet_wdb_empty_answ(request)) {
       goto end;
    }

    // Check empty answers
    if (wm_vuldet_wdb_empty_answ(request)) {
       goto end;
    }

    request[0] = request[1] = ' ';

    cJSON *obj=NULL, *obj_it=NULL;
    if (obj = cJSON_Parse(request), !obj) {
        goto end;
    }

    // We need the OS version in the format 'x.y'
    // To match the NVD vulnerabilities
    if ((obj_it = obj->child) && (obj_it = cJSON_GetObjectItem(obj_it, "os_version")) && obj_it->valuestring) {

        w_strdup(obj_it->valuestring, os_info_Ptr->os_version);
        if ((obj_it = obj->child) && (obj_it = cJSON_GetObjectItem(obj_it, "os_platform")) && obj_it->valuestring) {
            w_strdup(obj_it->valuestring, os_info_Ptr->os_platform);
            retval = 0;
        }
    }

    cJSON_free(obj);

    mtdebug1(WM_VULNDETECTOR_LOGTAG, "gmedian retrieved %s and %s from agent os_info", os_info_Ptr->os_platform, os_info_Ptr->os_version);
end:
#else
    os_info_Ptr->os_platform = (char*)malloc(7*sizeof(char));
    strcpy(os_info_Ptr->os_platform, "centos");
    os_info_Ptr->os_version = (char*)malloc(4*sizeof(char));
    strcpy(os_info_Ptr->os_version, "7.10");
    retval = 0;
#endif
    return retval;
}
 
static size_t write_callback(void *contents, size_t size, size_t nmemb, void *userp)
{
  size_t realsize = size * nmemb;
  struct Memory *mem = (struct Memory *)userp;
  char *ptr = realloc(mem->memory, mem->size + realsize + 1);
  if(!ptr) {
    /* out of memory! */ 
    printf("not enough memory (realloc returned NULL)\n");
    return 0;
  }
 
  mem->memory = ptr;
  memcpy(&(mem->memory[mem->size]), contents, realsize);
  mem->size += realsize;
  mem->memory[mem->size] = 0;
 
  return realsize;
}

static size_t read_callback(char *dest, size_t size, size_t nmemb, void *userp)
{
  struct Memory *wt = (struct Memory *)userp;
  size_t buffer_size = size*nmemb;
 
  if(wt->size) {
    /* copy as much as possible from the source to the destination */ 
    size_t copy_this_much = wt->size;
    if(copy_this_much > buffer_size)
      copy_this_much = buffer_size;
    memcpy(dest, wt->memory, copy_this_much);
 
    wt->memory += copy_this_much;
    wt->size -= copy_this_much;
    return copy_this_much; /* we copied this many bytes */ 
  }
 
  return 0; /* no more data left to deliver */ 
}

int get_vulners_api_key(char **vulners_key_Ptr)
{
    FILE *v_key_fPtr=NULL;

    if(v_key_fPtr=fopen(VULNERS_KEY_FILE, "r"), !v_key_fPtr)
    {
        perror("No vulners api key file found.");
        return -1;
    }
    fgets(*vulners_key_Ptr, 65, v_key_fPtr);

    fclose(v_key_fPtr);
    return 0;
}

void get_packages(const char *filename, char ***packages_array_Ptr)
{
    char **reallocPtr=NULL;
    FILE *fPtr=fopen(filename, "r");

    if(fPtr == NULL)
    {
        fputs("Error in opening file for reading package list", stderr);
        return;
    }

    *packages_array_Ptr=(char**)calloc(ALLOC_STEP, sizeof(char*));
    if(*packages_array_Ptr == NULL)
    {
        perror("Can't calloc memory for packages array in get_packages.");
        fclose(fPtr);
        return;
    }

    char *buf=NULL;
    u_int count=0, max_count=ALLOC_STEP;

    while(!feof(fPtr))
    {
        if(count >= max_count)
        {
            max_count += ALLOC_STEP;
            reallocPtr = (char**)realloc(*packages_array_Ptr, max_count * sizeof(char*));
            if(reallocPtr == NULL)
            {
                // here packages_array_Ptr still exists and holds data
                perror("Can't realloc for packages reading in get_packages. Continue with the existing ones.");
                break;
            }
            // otherwise - old packages_array_Ptr is already freed
            *packages_array_Ptr = reallocPtr;
        }
        (*packages_array_Ptr)[count] = (char*)malloc(STR_MAX_LEN * sizeof(char));
        if((*packages_array_Ptr)[count] == NULL)
        {
            perror("Can't malloc memory for another package name. Continue with the existing ones.");
            break;
        }
        buf = fgets((*packages_array_Ptr)[count], STR_MAX_LEN, fPtr);
        if(!buf)
        {
            if(ferror(fPtr))
            {
                // debug
                perror("Some error at reading the file. But something might have been read, so continue.");
                break;
            }
            else
            {
                // otherwise it is just an EOF right at the start, so just break out
                break;
            }
            
        }
        buf[strlen(buf)-1] = buf[strlen(buf)-1] == '\n'?'\0':buf[strlen(buf)-1]; //overwrite the present newline character
        count++;
    }

    fclose(fPtr); // success or not, it does not matter - we did our best here
    if(!count)
    {
        // nothing read, return NULL
        free(*packages_array_Ptr);
        return;
    }
    else
    {
        reallocPtr = (char**)realloc(*packages_array_Ptr, (count+1) * sizeof(char*));
        if(reallocPtr == NULL)
        {
            perror("Can't shrink memory with realloc after reading packages. Continue with the old size.");
        }
        else
        {
            *packages_array_Ptr = reallocPtr;
        }
        
        (*packages_array_Ptr)[count] = NULL;
        return;
    }
}

void write_vulns(struct Memory *dataPtr)
{
    FILE *ofPtr=fopen(VULNERS_VULN_PACKAGES_FILE, "w");
    if(ofPtr == NULL)
    {
        perror("Can't open a file for writing resulting vulnerabilities.");
        return; 
    }

    cJSON *in_json=cJSON_Parse(dataPtr->memory);
    cJSON *new_res=cJSON_CreateObject();

    if(in_json == NULL)
    {
        const char *error_ptr = cJSON_GetErrorPtr();
        if (error_ptr != NULL)
        {
            fprintf(stderr, "Error at json parsing before: %s\n", error_ptr);
        }
        goto end;
    }

    cJSON *item=NULL, *new_pkg=NULL, *pkg_obj=NULL, *pkg=NULL, *vuln=NULL, *vuln_reason=NULL,
        *cvelist=NULL, *cve=NULL;
    item = cJSON_GetObjectItemCaseSensitive(in_json, "result");
    if(cJSON_IsString(item) && !strcmp(item->valuestring, "OK"))
    {
        printf("Everything worked fine. We have OK in result!\n");
    }
    else
    {
        printf("Not OK in result or no result. We are totally doomed!\n");
        goto j_end;
    }

    item = cJSON_GetObjectItemCaseSensitive(in_json, "data");
    if(!cJSON_IsObject(item))
    {
        perror("\"data\" field not present or is not an object\n");
        goto j_end;
    }

    pkg_obj = cJSON_GetObjectItemCaseSensitive(item, "packages");
    if(!cJSON_IsObject(pkg_obj))
    {
        perror("\"packages\" field not present or is not an object\n");
        goto j_end;
    }

    cJSON_ArrayForEach(pkg, pkg_obj)
    {
        // pkg is an object
        if(!cJSON_IsObject(pkg))
        {
            perror("Single package is not an object\n");
            // assume some other packages might be found
            continue;
        }
        printf("Scanning for %s\n", pkg->string);
        new_pkg = cJSON_AddObjectToObject(new_res, pkg->string);
        cJSON *new_cvelist=cJSON_AddArrayToObject(new_pkg, "cvelist");
        cJSON_ArrayForEach(vuln, pkg)
        {
            // vuln is an array with reasons
            if(!cJSON_IsArray(vuln))
            {
                fprintf(stderr, "Single vuln in package %s is not an array\n", pkg->string);
                continue;
            }

            cJSON_ArrayForEach(vuln_reason, vuln)
            {
                // vuln_reason is an object
                if(!cJSON_IsObject(pkg))
                {
                    fprintf(stderr, "Single vuln_reason in %s and vuln %s is not an object\n", 
                            pkg->string, vuln->string);
                    continue;
                }
                cvelist = cJSON_GetObjectItemCaseSensitive(vuln_reason, "cvelist");
                if(!cJSON_IsArray(cvelist))
                {
                    // cvelist may be absent, so no big deal here
                    continue;
                }
                cJSON_ArrayForEach(cve, cvelist)
                {
                    if(!cJSON_IsString(cve))
                    {
                        fprintf(stderr, "Single cve in cvelist of pkg %s and vuln %s is not a string\n", 
                            pkg->string, vuln->string);
                    continue;
                    }
                    // FIXME remove duplicates
                    cJSON_AddItemReferenceToArray(new_cvelist, cve);
                }
            }
        }
    }

    char * j_str = cJSON_Print(new_res);
    if(j_str == NULL)
    {
        perror("Somethig horrible has happened - can't print the new result\n");
        goto j_end;
    }
    fputs(j_str, ofPtr);

    free(j_str);
j_end:    
    cJSON_Delete(in_json);
end:
    cJSON_Delete(new_res);
    fclose(ofPtr);
    return;
}
