#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <curl/curl.h>
#include <cJSON.h>

#include "vulners_wazuh.h"
#ifndef LOCAL_BUILD
    #include "../../wmodules.h"
    #include "../wm_vuln_detector.h"
#endif
#define VULNERS_API_KEY_LEN 65
#define CURL_VULNERS_AGENT "User-Agent: vulners-wazuh/0.1"
#define CURL_VULNERS_CONTENT_TYPE "Content-type: application/json"
#define CURL_VULNERS_CONTENT_LENGTH "Content-length: %d"
#define VULNERS_URL "https://vulners.com/api/v3/audit/audit/"
#define TEST_PROXY_URL "http://172.16.47.1:8089"
#define VULNERS_PAYLOAD "{\"os\": \"%s\", \"version\": %s, \"package\": [%s], \"apiKey\": \"%s\"}"
#define PACKAGES_FILE "/home/gmedian/Documents/projects/vulners/integrations/wazuh/test_url/packs.txt"
#define VULNERS_PAYLOAD_FILE "/home/gmedian/Documents/projects/vulners/integrations/wazuh/test_url/payload.txt"
#define VULNERS_RESULT_FILE "/home/gmedian/Documents/projects/vulners/integrations/wazuh/test_url/result.txt"
#define VULNERS_VULN_PACKAGES_FILE "/home/gmedian/Documents/projects/vulners/integrations/wazuh/test_url/vulnerable.txt"
#define VULNERS_KEY_FILE "/home/gmedian/Documents/projects/vulners/integrations/wazuh/test_url/vulners_key.txt"
#define ALLOC_STEP 128
#define STR_MAX_LEN 255 // + \0

#define check_null(ptr, msg) \
                            if(ptr == NULL) \
                            {\
                                perror(msg); \
                                goto end; \
                            }


// -D LOCAL_BUILD
#ifdef LOCAL_BUILD
int main(int argc, char **argv, char **env)
#else
int vulners_main(char *agent_id)
#endif
{
    int result=0;

    char *vulners_key=(char*)malloc(VULNERS_API_KEY_LEN*sizeof(char)); //API key len + \0

    result = get_vulners_api_key(&vulners_key);
    if(result)
    {
        perror("Failed to get vulners_api_key.");
        free(vulners_key);
        return -1;
    }

    char **packages_list=NULL;
    get_packages(PACKAGES_FILE, &packages_list);
    
    if(!packages_list)
    {
        return -1;
    }


//     cJSON *payload=cJSON_CreateObject(); 

//     v_os_info os_info;
// #ifdef LOCAL_BUILD
//     char *agent_id="000";
// #endif
//     result = get_os_info(&os_info, agent_id);

//     if(result)
//     {
//         fprintf(stderr, "Could not receive os_info for agent_id %s", agent_id);
//         goto end;
//     }

//     // FIXME add real os name here
//     if (cJSON_AddStringToObject(payload, "os", os_info.os_platform) == NULL)
//     {
//         perror("Can't add os field to JSON payload");
//         goto end;
//     }
//     if (cJSON_AddStringToObject(payload, "version", os_info.os_version) == NULL)
//     {
//         perror("Can't add version field to JSON payload");
//         goto end;
//     }
//     if (cJSON_AddStringToObject(payload, "apiKey", vulners_key) == NULL)
//     {
//         perror("Can't add version field to JSON payload");
//         goto end;
//     }

//     free(os_info.os_version);
//     free(os_info.os_platform);

//     cJSON *packages_array=cJSON_AddArrayToObject(payload, "package");


//     for(char **it=packages_list; *it != NULL; it++)
//     {
//         cJSON *package_name=cJSON_CreateString(*it);
//         if(package_name == NULL)
//         {
//             perror("Cant create JSON string field.");
//             goto end;
//         }
//         cJSON_AddItemToArray(packages_array, package_name);
//     }
#ifdef LOCAL_BUILD
    char *agent_id="000";
#endif

    v_os_info os_info;
    result = get_os_info(&os_info, agent_id);

    if(result)
    {
        fprintf(stderr, "Could not receive os_info for agent_id %s\n", agent_id);
        goto end;
    }

    cJSON *payload=get_cJSON_payload(packages_list, &os_info, vulners_key);
    free(os_info.os_version);
    free(os_info.os_platform);

    if(!payload)
    {
        fprintf(stderr, "Could not build cJSON payload for agent_id %s\n", agent_id);
        goto end;
    }
    char *payload_str=cJSON_Print(payload);


    CURL *curl=curl_easy_init();
    CURLcode res;
    char errbuf[CURL_ERROR_SIZE];
    struct curl_slist *c_header=NULL; 

    // char *buffer=(char*)calloc(1000, sizeof(char));

    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, NULL);
    curl_easy_setopt(curl, CURLOPT_URL, VULNERS_URL);
    curl_easy_setopt(curl, CURLOPT_PROXY, TEST_PROXY_URL);
    
    c_header = curl_slist_append(c_header, CURL_VULNERS_AGENT);
    c_header = curl_slist_append(c_header, CURL_VULNERS_CONTENT_TYPE);
    c_header = curl_slist_append(c_header, "Transfer-Encoding: chunked");
    

    // char * buffer=(char*)malloc(STR_MAX_LEN * sizeof(char));
    // snprintf(buffer, 900, CURL_VULNERS_CONTENT_LENGTH, strlen(payload_str));

    // c_header = curl_slist_append(c_header, buffer);

    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, c_header);

    // FILE *ifPtr = fopen(VULNERS_PAYLOAD_FILE, "r");

    // rewind(iofPtr);

    curl_easy_setopt(curl, CURLOPT_READFUNCTION, read_callback);
    curl_easy_setopt(curl, CURLOPT_POST, 1L);
    
    struct WriteThis wt;
 
    wt.readptr = (const char*)payload_str;
    wt.sizeleft = (size_t)strlen(payload_str);

    curl_easy_setopt(curl, CURLOPT_READDATA, &wt);
    

    // fclose(iofPtr);

    FILE * resfPtr = fopen(VULNERS_RESULT_FILE, "w+");

    if(!resfPtr)
    {
        perror("Cant open file for vulners result.\n");
        // fclose(iofPtr);
        goto end;
    }

    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, NULL);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, resfPtr);

    // curl_easy_setopt(curl, CURLOPT_POSTFIELDS, VULNERS_PAYLOAD);

    // TODO[gmedian]: fix SSL here
    if(!strncmp(VULNERS_URL, "https", 5)){
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
    }

    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf);
    curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);

    res = curl_easy_perform(curl);

    // in order to work on we need all the data present in the files
    // so flush the OS buffers now
    // fclose(iofPtr);
    fclose(resfPtr);

    switch (res)
    {
    case CURLE_OK:
        fprintf(stderr,"Got OK\n");
        write_vulns();
        break;
    
    default:
        fprintf(stderr, "Some curl problem arose. \n%s\n", errbuf);
        break;
    }

    curl_slist_free_all(c_header);
    curl_easy_cleanup(curl);

end:
    cJSON_Delete(payload);

    free(vulners_key);

    // write_vulns();

    // call wm_vuldet_send_cve_report here with report on vulnerabilities

    return 0;
}

cJSON* get_cJSON_payload(char **packages_list, v_os_info *os_info_Ptr, char *vulners_key)
{
    int result=0;

    cJSON *payload=cJSON_CreateObject(); 


    // FIXME add real os name here
    if (cJSON_AddStringToObject(payload, "os", os_info_Ptr->os_platform) == NULL)
    {
        perror("Can't add os field to JSON payload");
        goto error;
    }
    if (cJSON_AddStringToObject(payload, "version", os_info_Ptr->os_version) == NULL)
    {
        perror("Can't add version field to JSON payload");
        goto error;
    }
    if (cJSON_AddStringToObject(payload, "apiKey", vulners_key) == NULL)
    {
        perror("Can't add version field to JSON payload");
        goto error;
    }


    cJSON *packages_array=cJSON_AddArrayToObject(payload, "package");


    for(char **it=packages_list; *it != NULL; it++)
    {
        cJSON *package_name=cJSON_CreateString(*it);
        if(package_name == NULL)
        {
            perror("Cant create JSON string field.");
            goto error;
        }
        cJSON_AddItemToArray(packages_array, package_name);
    }

    return payload;
error:
    cJSON_Delete(payload);
    return NULL;
}

int get_os_info(v_os_info *infoPtr, char *agent_id)
{
    int retval=-1;
#ifndef LOCAL_BUILD
    char request[OS_SIZE_128];


    snprintf(request, OS_SIZE_128, "agent %s sql SELECT os_version, os_platform FROM SYS_OSINFO;", agent_id);

    mtdebug1(WM_VULNDETECTOR_LOGTAG, "gmedian trying to send request \"%s\" to wdb", request);

    if (wm_vuldet_wdb_request(request, OS_MAXSTR)) {
        goto end;
    }

    mtdebug1(WM_VULNDETECTOR_LOGTAG, "gmedian got response \"%s\" fom wdb", request);

    if (!wm_vuldet_wdb_valid_answ(request)) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_INV_WAZUHDB_RES, request);
        goto end;
    }

    // Check empty answers
    if (wm_vuldet_wdb_empty_answ(request)) {
       goto end;
    }

    // Check empty answers
    if (wm_vuldet_wdb_empty_answ(request)) {
       goto end;
    }

    request[0] = request[1] = ' ';

    cJSON *obj=NULL, *obj_it=NULL;
    if (obj = cJSON_Parse(request), !obj) {
        goto end;
    }

    // We need the OS version in the format 'x.y'
    // To match the NVD vulnerabilities
    if ((obj_it = obj->child) && (obj_it = cJSON_GetObjectItem(obj_it, "os_version")) && obj_it->valuestring) {

        w_strdup(obj_it->valuestring, infoPtr->os_version);
        if ((obj_it = obj->child) && (obj_it = cJSON_GetObjectItem(obj_it, "os_platform")) && obj_it->valuestring) {
            w_strdup(obj_it->valuestring, infoPtr->os_platform);
            retval = 0;
        }
    }

    cJSON_free(obj);

    mtdebug1(WM_VULNDETECTOR_LOGTAG, "gmedian retrieved %s and %s from agent os_info", infoPtr->os_platform, infoPtr->os_version);
end:
#else
    infoPtr->os_platform = (char*)malloc(7*sizeof(char));
    strcpy(infoPtr->os_platform, "centos");
    infoPtr->os_version = (char*)malloc(4*sizeof(char));
    strcpy(infoPtr->os_version, "7.10");
    retval = 0;
#endif
    return retval;
}

static size_t read_callback(char *dest, size_t size, size_t nmemb, void *userp)
{
  struct WriteThis *wt = (struct WriteThis *)userp;
  size_t buffer_size = size*nmemb;
 
  if(wt->sizeleft) {
    /* copy as much as possible from the source to the destination */ 
    size_t copy_this_much = wt->sizeleft;
    if(copy_this_much > buffer_size)
      copy_this_much = buffer_size;
    memcpy(dest, wt->readptr, copy_this_much);
 
    wt->readptr += copy_this_much;
    wt->sizeleft -= copy_this_much;
    return copy_this_much; /* we copied this many bytes */ 
  }
 
  return 0; /* no more data left to deliver */ 
}

int get_vulners_api_key(char **vulners_key_Ptr)
{
    FILE *v_key_fPtr=NULL;

    if(v_key_fPtr=fopen(VULNERS_KEY_FILE, "r"), !v_key_fPtr)
    {
        perror("No vulners api key file found.");
        return -1;
    }
    fgets(*vulners_key_Ptr, 65, v_key_fPtr);

    fclose(v_key_fPtr);
    return 0;
}

void get_packages(const char *filename, char ***packages_array_Ptr)
{
    char **reallocPtr=NULL;
    FILE *fPtr=fopen(filename, "r");

    if(fPtr == NULL)
    {
        fputs("Error in opening file for reading package list", stderr);
        return;
    }

    *packages_array_Ptr=(char**)calloc(ALLOC_STEP, sizeof(char*));
    if(*packages_array_Ptr == NULL)
    {
        perror("Can't calloc memory for packages array in get_packages.");
        fclose(fPtr);
        return;
    }

    char *buf=NULL;
    u_int count=0, max_count=ALLOC_STEP;

    while(!feof(fPtr))
    {
        if(count >= max_count)
        {
            max_count += ALLOC_STEP;
            reallocPtr = (char**)realloc(*packages_array_Ptr, max_count * sizeof(char*));
            if(reallocPtr == NULL)
            {
                // here packages_array_Ptr still exists and holds data
                perror("Can't realloc for packages reading in get_packages. Continue with the existing ones.");
                break;
            }
            // otherwise - old packages_array_Ptr is already freed
            *packages_array_Ptr = reallocPtr;
        }
        (*packages_array_Ptr)[count] = (char*)malloc(STR_MAX_LEN * sizeof(char));
        if((*packages_array_Ptr)[count] == NULL)
        {
            perror("Can't malloc memory for another package name. Continue with the existing ones.");
            break;
        }
        buf = fgets((*packages_array_Ptr)[count], STR_MAX_LEN, fPtr);
        if(!buf)
        {
            if(ferror(fPtr))
            {
                // debug
                perror("Some error at reading the file. But something might have been read, so continue.");
                break;
            }
            else
            {
                // otherwise it is just an EOF right at the start, so just break out
                break;
            }
            
        }
        buf[strlen(buf)-1] = buf[strlen(buf)-1] == '\n'?'\0':buf[strlen(buf)-1]; //overwrite the present newline character
        count++;
    }

    fclose(fPtr); // success or not, it does not matter - we did our best here
    if(!count)
    {
        // nothing read, return NULL
        free(*packages_array_Ptr);
        return;
    }
    else
    {
        reallocPtr = (char**)realloc(*packages_array_Ptr, (count+1) * sizeof(char*));
        if(reallocPtr == NULL)
        {
            perror("Can't shrink memory with realloc after reading packages. Continue with the old size.");
        }
        else
        {
            *packages_array_Ptr = reallocPtr;
        }
        
        (*packages_array_Ptr)[count] = NULL;
        return;
    }
}

void write_vulns()
{
    FILE *ifPtr=fopen(VULNERS_RESULT_FILE, "r");

    if(ifPtr == NULL)
    {
        perror("Can't reopen VULNERS_RESULT file for reading");
        return;
    }

    FILE *ofPtr=fopen(VULNERS_VULN_PACKAGES_FILE, "w");
    if(ofPtr == NULL)
    {
        perror("Can't open VULNERS_VULN file for writing");
        fclose(ifPtr);
        return; 
    }

    fseek (ifPtr, 0 , SEEK_END);
    long lSize = ftell (ifPtr);
    rewind (ifPtr);

    char *j_str=(char*)malloc(lSize * sizeof(char) + 1);
    check_null(j_str, "Can't malloc memory for json response.\n");
    if(fread(j_str, sizeof(char), lSize, ifPtr) < lSize)
    {
        // Since we tried for exactly the file size, no EOF could have been met
        // so an error must have occured
        perror("Some error at reading file with the json result.\n");
        free(j_str);
        goto end;
    }
    j_str[lSize] = '\0';

    cJSON *in_json=cJSON_Parse(j_str);
    cJSON *new_res=cJSON_CreateObject();

    if(in_json == NULL)
    {
        const char *error_ptr = cJSON_GetErrorPtr();
        if (error_ptr != NULL)
        {
            fprintf(stderr, "Error at json parsing before: %s\n", error_ptr);
        }
        free(j_str);
        goto end;
    }


    // if res.status_code == 200 and res.json().get('result') == "OK":
    // result = dict()
    // all_cve = list()
    // for pkg, info in res.json()['data'].get('packages', {}).items():
    //     cvelist = []
    //     for vuln_name, desc in info.items():
    //         cvelist.append(sum(map(lambda x: x.get("cvelist", []), desc), []))
    //     cvelist = list(set(sum(cvelist, [])))
    //     if len(cvelist):
    //         result[pkg] = {"cve": cvelist}
    //         all_cve += cvelist
    // result['all_cve'] = all_cve
    // return result

    cJSON *item=NULL, *new_pkg=NULL, *pkg_obj=NULL, *pkg=NULL, *vuln=NULL, *vuln_reason=NULL,
        *cvelist=NULL, *cve=NULL;
    item = cJSON_GetObjectItemCaseSensitive(in_json, "result");
    if(cJSON_IsString(item) && !strcmp(item->valuestring, "OK"))
    {
        printf("Everything worked fine. We have OK in result!\n");
    }
    else
    {
        printf("Not OK in result or no result. We are totally doomed!\n");
        goto j_end;
    }

    item = cJSON_GetObjectItemCaseSensitive(in_json, "data");
    if(!cJSON_IsObject(item))
    {
        perror("\"data\" field not present or is not an object\n");
        goto j_end;
    }

    pkg_obj = cJSON_GetObjectItemCaseSensitive(item, "packages");
    if(!cJSON_IsObject(pkg_obj))
    {
        perror("\"packages\" field not present or is not an object\n");
        goto j_end;
    }

    cJSON_ArrayForEach(pkg, pkg_obj)
    {
        // pkg is an object
        if(!cJSON_IsObject(pkg))
        {
            perror("Single package is not an object\n");
            // assume some other packages might be found
            continue;
        }
        printf("Scanning for %s\n", pkg->string);
        new_pkg = cJSON_AddObjectToObject(new_res, pkg->string);
        cJSON *new_cvelist=cJSON_AddArrayToObject(new_pkg, "cvelist");
        cJSON_ArrayForEach(vuln, pkg)
        {
            // vuln is an array with reasons
            if(!cJSON_IsArray(vuln))
            {
                fprintf(stderr, "Single vuln in package %s is not an array\n", pkg->string);
                continue;
            }

            cJSON_ArrayForEach(vuln_reason, vuln)
            {
                // vuln_reason is an object
                if(!cJSON_IsObject(pkg))
                {
                    fprintf(stderr, "Single vuln_reason in %s and vuln %s is not an object\n", 
                            pkg->string, vuln->string);
                    continue;
                }
                cvelist = cJSON_GetObjectItemCaseSensitive(vuln_reason, "cvelist");
                if(!cJSON_IsArray(cvelist))
                {
                    // cvelist may be absent, so no big deal here
                    continue;
                }
                cJSON_ArrayForEach(cve, cvelist)
                {
                    if(!cJSON_IsString(cve))
                    {
                        fprintf(stderr, "Single cve in cvelist of pkg %s and vuln %s is not a string\n", 
                            pkg->string, vuln->string);
                    continue;
                    }
                    // FIXME remove duplicates
                    cJSON_AddItemReferenceToArray(new_cvelist, cve);
                }
            }
        }
    }

    free(j_str);
    j_str = cJSON_Print(new_res);
    if(j_str == NULL)
    {
        perror("Somethig horrible has happened - can't print the new result\n");
        goto j_end;
    }
    fputs(j_str, ofPtr);

j_end:    
    cJSON_Delete(in_json);
    cJSON_Delete(new_res);
    free(j_str);
end:
    fclose(ifPtr);
    fclose(ofPtr);
    return;
}
